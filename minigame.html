<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Work Escape V8 - Ultimate</title>
  
  <!-- Font Caricati -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <style>
    :root {
      --bg-color: #0f172a;
      --wall-color: #1e293b;
      --wall-border: #334155;
      --primary: #5B6FED;
      --accent: #4cd964;
      --danger: #ff6b6b;
      --boost: #facc15;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: #f8fafc;
      font-family: 'Inter', sans-serif;
      overflow: hidden; /* Blocca scroll */
      touch-action: none; /* Blocca zoom browser */
      display: flex;
      flex-direction: column;
      height: 100vh;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* HEADER */
    .game-header {
      flex: 0 0 60px;
      padding: 0 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0,0,0,0.5);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      z-index: 100;
    }
    
    .score-box {
      font-family: 'Orbitron', sans-serif;
      font-size: 20px;
      color: #fff;
      text-shadow: 0 0 10px var(--primary);
      transition: transform 0.2s;
    }
    .score-boosted {
      color: var(--boost);
      text-shadow: 0 0 20px var(--boost);
      transform: scale(1.1);
    }
    
    .btn-reset {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      width: 40px; height: 40px;
      border-radius: 50%;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }

    /* GAME AREA */
    #game-wrapper {
      flex: 1;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #0b1120;
      overflow: hidden;
      width: 100%;
    }

    canvas {
      box-shadow: 0 0 50px rgba(0,0,0,0.8);
      border-radius: 8px;
      image-rendering: pixelated; /* Nitidezza pixel */
      touch-action: none;
    }

    /* OVERLAYS */
    .overlay {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
      text-align: center;
      backdrop-filter: blur(8px);
    }
    
    .hidden { display: none !important; }

    h1 {
      font-family: 'Orbitron';
      font-size: 32px;
      margin: 10px 0;
      background: linear-gradient(to right, #4cd964, #5B6FED);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .btn-action {
      background: var(--primary);
      color: white;
      border: none;
      padding: 16px 40px;
      border-radius: 50px;
      font-size: 18px;
      font-weight: 700;
      margin-top: 30px;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(91, 111, 237, 0.4);
      transition: transform 0.1s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .btn-action:active { transform: scale(0.95); }

    .items-hud {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    .hud-item {
      font-size: 28px;
      opacity: 0.3;
      filter: grayscale(100%);
      transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .hud-item.collected {
      opacity: 1;
      filter: grayscale(0%);
      transform: scale(1.4);
      text-shadow: 0 0 15px rgba(255,255,255,0.8);
    }

    /* Feedback Tocco */
    .touch-marker {
        position: absolute;
        width: 30px; height: 30px;
        border: 3px solid rgba(255,255,255,0.8);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 150;
        animation: ripple 0.5s ease-out forwards;
    }
    @keyframes ripple {
        0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; border-width: 5px; }
        100% { transform: translate(-50%, -50%) scale(2.0); opacity: 0; border-width: 0px; }
    }
    
    .debug-info {
        position: absolute; bottom: 5px; width: 100%;
        text-align: center; font-size: 10px; color: #475569;
        pointer-events: none;
    }

  </style>
</head>
<body>

  <div class="game-header">
    <div class="score-box" id="score-display">PUNTI: <span id="score-val">0</span></div>
    <button class="btn-reset" onclick="Game.restart()"><i class="fas fa-undo"></i></button>
  </div>

  <div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>

    <!-- START SCREEN -->
    <div id="start-screen" class="overlay">
      <div style="font-size:60px; margin-bottom:10px;">ü§ñ</div>
      <h1>WORK ESCAPE</h1>
      <p style="color:#94a3b8; font-size:14px; margin-bottom:5px;">Evita: üìß üíº üìû</p>
      <p style="color:#facc15; font-size:12px;">Raccogli oggetti per il TURBO ‚ö°</p>
      
      <div class="items-hud" style="margin-top:20px;">
        <span id="hud-heart" class="hud-item">‚ù§Ô∏è</span>
        <span id="hud-house" class="hud-item">üè†</span>
        <span id="hud-dance" class="hud-item">üíÉ</span>
        <span id="hud-travel" class="hud-item">‚úàÔ∏è</span>
      </div>

      <button class="btn-action" onclick="Game.start()">GIOCA</button>
      <div style="font-size:11px; color:#64748b; margin-top:20px;">TOCCA PER MUOVERTI</div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="lose-screen" class="overlay hidden">
      <div style="font-size:60px; margin-bottom:10px;">üíÄ</div>
      <h1 style="color:var(--danger)">CATTURATO</h1>
      <p style="color:#cbd5e1;">Il lavoro ti ha raggiunto.</p>
      <p style="font-family:'Orbitron'; font-size:24px; margin-top:15px;">Punti: <span id="final-score-lose">0</span></p>
      <button class="btn-action" onclick="Game.restart()">RIPROVA</button>
    </div>

    <!-- WIN SCREEN -->
    <div id="win-screen" class="overlay hidden">
      <div style="font-size:60px; margin-bottom:10px;">üèÜ</div>
      <h1 style="color:var(--accent)">LIBERT√Ä!</h1>
      <p style="color:#cbd5e1;">Hai completato la tua vita!</p>
      <div style="background:rgba(76, 217, 100, 0.2); color:#4cd964; padding:10px 20px; border-radius:10px; margin-top:15px; font-weight:bold; font-family:'Orbitron';">
        TOTALE: 500 PUNTI
      </div>
      <button class="btn-action" onclick="Game.restart()">NUOVA PARTITA</button>
    </div>
    
    <div class="debug-info">Sistema Input V8 Attivo</div>
  </div>

  <script>
    /**
     * ALGORITMO DI PATHFINDING (BFS)
     * Calcola il percorso pi√π breve evitando i muri.
     */
    const Pathfinder = {
        findPath: function(map, start, end) {
            const rows = map.length;
            const cols = map[0].length;
            
            // Assicuriamoci che start e end siano interi
            const s = {x: Math.round(start.x), y: Math.round(start.y)};
            const e = {x: Math.round(end.x), y: Math.round(end.y)};

            // Se il target √® un muro, non possiamo andarci
            if(map[e.y][e.x] === 1) return [];

            const queue = [s];
            const cameFrom = {}; // Per ricostruire il percorso
            cameFrom[`${s.x},${s.y}`] = null;
            
            const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}]; // Su, Gi√π, Sx, Dx
            
            let found = false;
            let safetyCounter = 0; // Prevenzione loop infiniti

            while(queue.length > 0 && safetyCounter < 1000) {
                safetyCounter++;
                const current = queue.shift();

                if(current.x === e.x && current.y === e.y) {
                    found = true;
                    break;
                }

                for(let d of dirs) {
                    const next = {x: current.x + d.x, y: current.y + d.y};
                    const key = `${next.x},${next.y}`;

                    if(next.x >= 0 && next.x < cols && 
                       next.y >= 0 && next.y < rows && 
                       map[next.y][next.x] !== 1 && // Non √® un muro
                       !(key in cameFrom)) { // Non visitato
                        
                        queue.push(next);
                        cameFrom[key] = current;
                    }
                }
            }

            if(!found) return [];

            // Ricostruzione percorso a ritroso
            let curr = e;
            const path = [];
            while(curr.x !== s.x || curr.y !== s.y) {
                const prev = cameFrom[`${curr.x},${curr.y}`];
                // Salviamo la direzione (vettore)
                path.push({x: curr.x - prev.x, y: curr.y - prev.y});
                curr = prev;
            }
            return path.reverse(); // Dall'inizio alla fine
        }
    };

    /**
     * GENERATORE DI LABIRINTI
     * Crea mappe procedurali sempre diverse.
     */
    const MapGenerator = {
        create: function(rows, cols) {
            // Riempi tutto di muri (1)
            let map = Array(rows).fill().map(() => Array(cols).fill(1));
            
            // Algoritmo Recursive Backtracker (Iterativo con stack)
            const stack = [{x: 1, y: 1}];
            map[1][1] = 0;
            
            const dirs = [
                {x:0, y:-2}, {x:0, y:2}, {x:-2, y:0}, {x:2, y:0}
            ];

            while(stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];

                dirs.forEach(d => {
                    const nx = current.x + d.x;
                    const ny = current.y + d.y;
                    
                    if(nx > 0 && nx < cols-1 && ny > 0 && ny < rows-1 && map[ny][nx] === 1) {
                        neighbors.push({x: nx, y: ny, dx: d.x/2, dy: d.y/2});
                    }
                });

                if(neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    // Abbatti muro intermedio
                    map[current.y + next.dy][current.x + next.dx] = 0;
                    // Abbatti muro destinazione
                    map[next.y][next.x] = 0;
                    stack.push({x: next.x, y: next.y});
                } else {
                    stack.pop();
                }
            }

            // Aggiungi Loop (rimuovi muri a caso) per non avere troppi vicoli ciechi
            for(let y=1; y<rows-1; y++) {
                for(let x=1; x<cols-1; x++) {
                    if(map[y][x] === 1 && Math.random() < 0.20) {
                        // Controlla di non creare spazi aperti enormi
                        let surroundingWalls = 0;
                        if(map[y-1][x]) surroundingWalls++;
                        if(map[y+1][x]) surroundingWalls++;
                        if(map[y][x-1]) surroundingWalls++;
                        if(map[y][x+1]) surroundingWalls++;
                        
                        if(surroundingWalls >= 2) map[y][x] = 0;
                    }
                }
            }

            // Assicura spawn point libero
            map[1][1] = 0; 
            
            return map;
        }
    };

    /**
     * LOGICA DI GIOCO PRINCIPALE
     */
    const Game = {
        canvas: null,
        ctx: null,
        rows: 21,
        cols: 13,
        gridSize: 0,
        
        map: [],
        player: null,
        enemies: [],
        items: [],
        
        state: 'menu', // menu, playing, win, lose
        score: 0,
        pathQueue: [], // Coda dei movimenti del player
        targetPos: null, // Dove ho cliccato
        
        baseSpeed: 0.20,
        boostSpeed: 0.45,
        boostTimer: null,

        init: function() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            
            // Gestione ridimensionamento
            this.resize();
            window.addEventListener('resize', () => this.resize());
            
            // --- GESTIONE INPUT ROBUSTA (Fix Chrome) ---
            const handleInput = (e) => {
                if(this.state !== 'playing') return;
                
                // Previene comportamenti di default (zoom, scroll)
                if(e.cancelable) e.preventDefault();
                
                // 1. Ottieni le coordinate precise del canvas nella pagina
                const rect = this.canvas.getBoundingClientRect();
                
                // 2. Normalizza input Mouse vs Touch
                let clientX, clientY;
                if(e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                // 3. Calcola la posizione relativa al canvas (in pixel CSS)
                const cssX = clientX - rect.left;
                const cssY = clientY - rect.top;

                // 4. Calcola il rapporto di scala (Pixel Interni / Pixel CSS)
                // Questo √® cruciale sui display Retina/HighDPI o se il CSS ridimensiona il canvas
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;

                // 5. Converti in coordinate interne del canvas
                const canvasX = cssX * scaleX;
                const canvasY = cssY * scaleY;

                // 6. Converti in coordinate griglia
                const gridX = Math.floor(canvasX / this.gridSize);
                const gridY = Math.floor(canvasY / this.gridSize);
                
                // Feedback Visivo Tocco
                this.createTouchMarker(clientX, clientY);

                // Logica Movimento
                this.handleGridClick(gridX, gridY);
            };

            // Usa 'touchstart' per mobile (pi√π reattivo) e 'mousedown' per desktop
            this.canvas.addEventListener('touchstart', handleInput, {passive: false});
            this.canvas.addEventListener('mousedown', handleInput);
        },

        resize: function() {
            const wrapper = document.getElementById('game-wrapper');
            // Calcola dimensione cella basata sullo spazio disponibile
            // Lascia un piccolo margine (-10px)
            const w = wrapper.clientWidth - 10;
            const h = wrapper.clientHeight - 10;
            
            const cellW = Math.floor(w / this.cols);
            const cellH = Math.floor(h / this.rows);
            
            this.gridSize = Math.min(cellW, cellH);
            
            // Imposta dimensioni interne canvas
            this.canvas.width = this.gridSize * this.cols;
            this.canvas.height = this.gridSize * this.rows;
            
            // Ridisegna se in pausa
            if(this.state !== 'playing' && this.map.length > 0) this.draw();
        },

        createTouchMarker: function(x, y) {
            const el = document.createElement('div');
            el.className = 'touch-marker';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 500);
        },

        handleGridClick: function(tx, ty) {
            // Verifica limiti
            if(tx < 0 || tx >= this.cols || ty < 0 || ty >= this.rows) return;
            
            // Verifica Muro (con tolleranza: se clicchi muro, cerca vicino libero)
            if(this.map[ty][tx] === 1) {
                // Cerca in un raggio di 1 casella se c'√® spazio libero
                const neighbors = [
                    {x:0,y:1}, {x:0,y:-1}, {x:1,y:0}, {x:-1,y:0}
                ];
                let foundAlt = false;
                for(let n of neighbors) {
                    if(this.isValid(tx+n.x, ty+n.y) && this.map[ty+n.y][tx+n.x] === 0) {
                        tx += n.x; ty += n.y;
                        foundAlt = true;
                        break;
                    }
                }
                if(!foundAlt) return; // Muro vero, niente da fare
            }

            this.targetPos = {x: tx, y: ty};
            
            // Calcolo percorso
            let startNode = {
                x: Math.round(this.player.x), 
                y: Math.round(this.player.y)
            };
            
            // Se il player si sta muovendo, calcola il percorso partendo dalla cella verso cui sta andando
            // per evitare scatti strani
            if(this.player.progress > 0.1) {
                startNode.x += this.player.dir.x;
                startNode.y += this.player.dir.y;
            }

            const path = Pathfinder.findPath(this.map, startNode, this.targetPos);
            if(path.length > 0) {
                this.pathQueue = path;
            }
        },

        isValid: function(x, y) {
            return x>=0 && x<this.cols && y>=0 && y<this.rows;
        },

        start: function() {
            // UI Reset
            document.querySelectorAll('.overlay').forEach(el => el.classList.add('hidden'));
            document.querySelectorAll('.hud-item').forEach(el => el.classList.remove('collected'));
            document.getElementById('score-display').classList.remove('score-boosted');
            
            // Game Reset
            if(this.boostTimer) clearTimeout(this.boostTimer);
            this.map = MapGenerator.create(this.rows, this.cols);
            this.spawnEntities();
            this.score = 0;
            document.getElementById('score-val').innerText = '0';
            this.pathQueue = [];
            this.targetPos = null;
            
            this.state = 'playing';
            this.loop();
        },

        restart: function() {
            this.start();
        },

        spawnEntities: function() {
            // Trova tutti gli spazi liberi
            let freeSpots = [];
            for(let y=0; y<this.rows; y++) {
                for(let x=0; x<this.cols; x++) {
                    if(this.map[y][x] === 0) freeSpots.push({x,y});
                }
            }
            
            // Mischia
            freeSpots.sort(() => Math.random() - 0.5);
            
            // Player (vicino all'inizio 1,1)
            let pSpot = freeSpots.find(s => s.x < 5 && s.y < 5) || freeSpots[0];
            this.player = {
                x: pSpot.x, y: pSpot.y,
                dir: {x:0, y:0},
                speed: this.baseSpeed,
                progress: 0
            };
            
            // Rimuovi spot player
            freeSpots = freeSpots.filter(s => s !== pSpot);
            
            // Ordina restanti per distanza dal player (per mettere nemici lontani)
            freeSpots.sort((a,b) => {
                const distA = Math.abs(a.x - pSpot.x) + Math.abs(a.y - pSpot.y);
                const distB = Math.abs(b.x - pSpot.x) + Math.abs(b.y - pSpot.y);
                return distB - distA; // Decrescente
            });
            
            // Items (4 oggetti)
            this.items = [
                { id: 'heart', icon: '‚ù§Ô∏è', x: freeSpots[0].x, y: freeSpots[0].y, collected: false },
                { id: 'house', icon: 'üè†', x: freeSpots[1].x, y: freeSpots[1].y, collected: false },
                { id: 'dance', icon: 'üíÉ', x: freeSpots[2].x, y: freeSpots[2].y, collected: false },
                { id: 'travel', icon: '‚úàÔ∏è', x: freeSpots[3].x, y: freeSpots[3].y, collected: false }
            ];
            
            // Nemici (3 tipi)
            this.enemies = [
                { type: 'smart', icon: 'üìß', x: freeSpots[4].x, y: freeSpots[4].y, dir: {x:0,y:0}, progress:0, speed: 0.11 },
                { type: 'dumb',  icon: 'üíº', x: freeSpots[5].x, y: freeSpots[5].y, dir: {x:0,y:0}, progress:0, speed: 0.08 },
                { type: 'smart', icon: 'üìû', x: freeSpots[6].x, y: freeSpots[6].y, dir: {x:0,y:0}, progress:0, speed: 0.12 }
            ];
        },

        update: function() {
            // 1. Movimento Player
            this.moveActor(this.player, true);
            
            // 2. Movimento Nemici
            this.enemies.forEach(enemy => {
                // Se il nemico √® fermo nella casella, decide dove andare
                if(enemy.progress === 0) {
                    if(enemy.type === 'smart') {
                        // Calcola percorso verso player
                        const path = Pathfinder.findPath(this.map, enemy, this.player);
                        if(path.length > 0) enemy.dir = path[0];
                    } else {
                        // Movimento casuale ma valido
                        const possible = [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]
                            .filter(d => {
                                const nx = Math.round(enemy.x) + d.x;
                                const ny = Math.round(enemy.y) + d.y;
                                return this.isValid(nx, ny) && this.map[ny][nx] === 0;
                            });
                        if(possible.length > 0) {
                            enemy.dir = possible[Math.floor(Math.random()*possible.length)];
                        }
                    }
                }
                this.moveActor(enemy, false);
            });
            
            // 3. Collisioni
            this.checkCollisions();
        },

        moveActor: function(actor, isPlayer) {
            // Se sta attraversando una casella
            if(actor.progress > 0) {
                actor.progress += actor.speed;
                if(actor.progress >= 1) {
                    // Movimento finito
                    actor.x += actor.dir.x;
                    actor.y += actor.dir.y;
                    actor.progress = 0;
                    actor.dir = {x:0, y:0};
                    
                    if(isPlayer && this.targetPos && actor.x === this.targetPos.x && actor.y === this.targetPos.y) {
                        this.targetPos = null;
                    }
                }
            } 
            // Se √® fermo e ci sono comandi in coda (solo player)
            else if (isPlayer && this.pathQueue.length > 0) {
                actor.dir = this.pathQueue.shift();
                actor.progress = actor.speed;
            }
            // Nemici (se hanno direzione impostata nell'update)
            else if (!isPlayer && (actor.dir.x !== 0 || actor.dir.y !== 0)) {
                actor.progress = actor.speed;
            }
        },

        checkCollisions: function() {
            const px = this.player.x + (this.player.dir.x * this.player.progress);
            const py = this.player.y + (this.player.dir.y * this.player.progress);
            
            // Items
            this.items.forEach(item => {
                if(!item.collected) {
                    if(Math.abs(px - item.x) < 0.5 && Math.abs(py - item.y) < 0.5) {
                        item.collected = true;
                        this.score += 100;
                        document.getElementById('score-val').innerText = this.score;
                        document.getElementById(`hud-${item.id}`).classList.add('collected');
                        
                        // Attiva Boost
                        this.triggerBoost();
                        
                        // Check Win
                        if(this.items.every(i => i.collected)) {
                            this.endGame(true);
                        }
                    }
                }
            });
            
            // Enemies
            this.enemies.forEach(enemy => {
                const ex = enemy.x + (enemy.dir.x * enemy.progress);
                const ey = enemy.y + (enemy.dir.y * enemy.progress);
                
                // Hitbox collisione
                if(Math.abs(px - ex) < 0.6 && Math.abs(py - ey) < 0.6) {
                    this.endGame(false);
                }
            });
        },

        triggerBoost: function() {
            if(this.boostTimer) clearTimeout(this.boostTimer);
            this.player.speed = this.boostSpeed;
            document.getElementById('score-display').classList.add('score-boosted');
            this.boostTimer = setTimeout(() => {
                this.player.speed = this.baseSpeed;
                document.getElementById('score-display').classList.remove('score-boosted');
            }, 3000);
        },

        endGame: function(win) {
            this.state = win ? 'win' : 'lose';
            if(win) {
                this.score += 100; // Bonus completamento
                document.getElementById('win-screen').classList.remove('hidden');
            } else {
                document.getElementById('final-score-lose').innerText = this.score;
                document.getElementById('lose-screen').classList.remove('hidden');
            }
        },

        draw: function() {
            // Background
            this.ctx.fillStyle = '#0b1120';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            
            const gs = this.gridSize;

            // 1. Disegna Mappa
            for(let y=0; y<this.rows; y++) {
                for(let x=0; x<this.cols; x++) {
                    if(this.map[y][x] === 1) {
                        const posX = x * gs;
                        const posY = y * gs;
                        
                        // Muro esterno
                        this.ctx.fillStyle = '#1e293b';
                        this.ctx.fillRect(posX, posY, gs, gs);
                        
                        // Dettaglio interno "3D" top-down
                        this.ctx.fillStyle = '#334155';
                        this.ctx.fillRect(posX+2, posY+2, gs-4, gs-4);
                    }
                }
            }

            // 2. Disegna Target Marker (se attivo)
            if(this.targetPos) {
                const tx = this.targetPos.x * gs + gs/2;
                const ty = this.targetPos.y * gs + gs/2;
                
                this.ctx.strokeStyle = '#4cd964';
                this.ctx.lineWidth = 2;
                
                // Animazione pulsante
                const pulse = (Math.sin(Date.now() / 150) + 1) * 3;
                this.ctx.beginPath();
                this.ctx.arc(tx, ty, (gs/4) + pulse, 0, Math.PI*2);
                this.ctx.stroke();
            }

            // 3. Disegna Oggetti
            this.ctx.font = `${gs * 0.6}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            
            this.items.forEach(item => {
                if(!item.collected) {
                    this.ctx.fillText(item.icon, item.x*gs + gs/2, item.y*gs + gs/2 + 2);
                }
            });

            // 4. Disegna Player
            const px = (this.player.x + this.player.dir.x * this.player.progress) * gs + gs/2;
            const py = (this.player.y + this.player.dir.y * this.player.progress) * gs + gs/2;
            
            this.ctx.font = `${gs * 0.75}px Arial`;
            
            // Effetto glow se veloce
            if(this.player.speed > this.baseSpeed) {
                this.ctx.shadowColor = '#facc15';
                this.ctx.shadowBlur = 15;
            }
            this.ctx.fillText('ü§ñ', px, py + 2);
            this.ctx.shadowBlur = 0;

            // 5. Disegna Nemici
            this.enemies.forEach(e => {
                const ex = (e.x + e.dir.x * e.progress) * gs + gs/2;
                const ey = (e.y + e.dir.y * e.progress) * gs + gs/2;
                this.ctx.fillText(e.icon, ex, ey + 2);
            });
        },

        loop: function() {
            if(this.state !== 'playing') return;
            this.update();
            this.draw();
            requestAnimationFrame(() => this.loop());
        }
    };

    // Avvio al caricamento
    window.onload = function() {
        Game.init();
    };

  </script>
</body>
</html>
