<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Work Escape V5 - Smart AI & Boost</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <style>
    :root {
      --bg-color: #0f172a;
      --wall-color: #1e293b;
      --primary: #5B6FED;
      --accent: #4cd964;
      --danger: #ff6b6b;
      --boost: #facc15;
    }

    body {
      margin: 0; padding: 0;
      background-color: var(--bg-color);
      color: #f8fafc;
      font-family: 'Inter', sans-serif;
      overflow: hidden; touch-action: none;
      display: flex; flex-direction: column;
      height: 100vh; user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .game-header {
      padding: 10px 15px;
      display: flex; justify-content: space-between; align-items: center;
      background: rgba(0,0,0,0.3); z-index: 10;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      height: 60px; box-sizing: border-box;
    }
    .score-container { font-family: 'Orbitron', sans-serif; font-size: 18px; color: #fff; text-shadow: 0 0 5px var(--primary); transition: all 0.2s; }
    .score-boosted { color: var(--boost) !important; text-shadow: 0 0 15px var(--boost) !important; transform: scale(1.1); }
    
    .close-btn { background: none; border: none; color: #94a3b8; font-size: 20px; cursor: pointer; }

    #game-wrapper {
      flex: 1; position: relative;
      display: flex; justify-content: center; align-items: center;
      background: var(--bg-color);
      overflow: hidden;
    }

    canvas {
      box-shadow: 0 0 30px rgba(0,0,0,0.6);
      border-radius: 4px;
    }

    .overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(15, 23, 42, 0.96);
      display: flex; flex-direction: column;
      justify-content: center; align-items: center;
      z-index: 20; text-align: center;
      backdrop-filter: blur(5px);
    }
    .hidden { display: none !important; }

    h2 { font-family: 'Orbitron'; font-size: 28px; margin: 0 0 10px 0; }
    .win-text { color: var(--accent); }
    .lose-text { color: var(--danger); }
    
    .btn-action {
      background: var(--primary); color: white; border: none;
      padding: 14px 35px; border-radius: 30px;
      font-size: 16px; font-weight: 600; margin-top: 25px;
      cursor: pointer; box-shadow: 0 4px 15px rgba(91, 111, 237, 0.4);
    }
    .btn-action:active { transform: scale(0.95); }

    .items-hud { display: flex; gap: 15px; margin-bottom: 20px; }
    .hud-item { font-size: 24px; opacity: 0.3; filter: grayscale(100%); transition: all 0.3s; }
    .hud-item.collected { opacity: 1; filter: grayscale(0%); transform: scale(1.3); text-shadow: 0 0 10px var(--accent); }

    /* Boost Effect on Canvas Container */
    .game-boosted canvas { box-shadow: 0 0 40px rgba(250, 204, 21, 0.3); border: 1px solid rgba(250, 204, 21, 0.5); }
  </style>
</head>
<body>

  <div class="game-header">
    <div class="score-container" id="score-box">SCORE: <span id="score-val">0</span>/500</div>
    <button class="close-btn"><i class="fas fa-times"></i></button>
  </div>

  <div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>

    <div id="start-screen" class="overlay">
      <div style="font-size:60px; margin-bottom:10px;">ü§ñ</div>
      <h2>WORK ESCAPE</h2>
      <p style="color:#94a3b8; font-size:14px; margin-bottom:5px;">Evita: üìß üíº üìû (Sono intelligenti!)</p>
      <p style="color:#facc15; font-size:12px; margin-bottom:20px;">Oggetti = +100 Punti & BOOST Velocit√† ‚ö°</p>
      
      <div class="items-hud">
        <span id="hud-heart" class="hud-item">‚ù§Ô∏è</span>
        <span id="hud-house" class="hud-item">üè†</span>
        <span id="hud-dance" class="hud-item">üíÉ</span>
        <span id="hud-travel" class="hud-item">‚úàÔ∏è</span>
      </div>

      <button class="btn-action" onclick="MazeGame.start()">INIZIA SFIDA</button>
      <div style="font-size:11px; color:#64748b; margin-top:15px;">TOCCA PER MUOVERTI</div>
    </div>

    <div id="game-over-screen" class="overlay hidden">
      <div style="font-size:60px; margin-bottom:10px;">üíÄ</div>
      <h2 class="lose-text">CATTURATO!</h2>
      <p style="color:#cbd5e1;">L'intelligenza artificiale ti ha preso.</p>
      <p style="font-family:'Orbitron'; font-size:20px;">Punti: <span id="final-score-lose">0</span></p>
      <button class="btn-action" onclick="MazeGame.start()">RIPROVA</button>
    </div>

    <div id="win-screen" class="overlay hidden">
      <div style="font-size:60px; margin-bottom:10px;">üèÜ</div>
      <h2 class="win-text">LIBERT√Ä!</h2>
      <p style="color:#cbd5e1;">Sei pi√π veloce del lavoro!</p>
      <div style="background:rgba(76, 217, 100, 0.2); color:#4cd964; padding:10px 20px; border-radius:10px; margin-top:15px; font-weight:bold; font-family:'Orbitron';">
        TOTALE: 500 PUNTI
      </div>
      <button class="btn-action" onclick="MazeGame.start()">NUOVA MAPPA</button>
    </div>
  </div>

  <script>
    // --- PATHFINDER (BFS) Condiviso (Player & Enemies) ---
    const Pathfinder = {
        findPath: function(map, start, end) {
            const rows = map.length;
            const cols = map[0].length;
            
            // Approssimiamo le coordinate a interi per la griglia
            const sNode = {x: Math.round(start.x), y: Math.round(start.y)};
            const eNode = {x: Math.round(end.x), y: Math.round(end.y)};

            if(map[eNode.y][eNode.x] === 1) return []; // Muro

            const queue = [sNode];
            const cameFrom = {};
            const startKey = `${sNode.x},${sNode.y}`;
            cameFrom[startKey] = null;
            const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
            
            let found = false;
            // Limite iterazioni per performance nemici (non bloccare il thread)
            let iterations = 0; 

            while(queue.length > 0 && iterations < 500) {
                iterations++;
                const current = queue.shift();
                if(current.x === eNode.x && current.y === eNode.y) { found = true; break; }

                for(let d of dirs) {
                    const next = {x: current.x + d.x, y: current.y + d.y};
                    const nextKey = `${next.x},${next.y}`;
                    if(next.x >= 0 && next.x < cols && next.y >= 0 && next.y < rows && 
                       map[next.y][next.x] !== 1 && !(nextKey in cameFrom)) {
                        queue.push(next);
                        cameFrom[nextKey] = current;
                    }
                }
            }

            if(!found) return []; // Nessun percorso

            // Ricostruzione
            let current = eNode;
            const path = [];
            while(current.x !== sNode.x || current.y !== sNode.y) {
                const key = `${current.x},${current.y}`;
                const prev = cameFrom[key];
                if(!prev) break; 
                path.push({x: current.x - prev.x, y: current.y - prev.y});
                current = prev;
            }
            return path.reverse();
        }
    };

    const MazeGen = {
        generate: function(rows, cols) {
            let map = Array(rows).fill().map(() => Array(cols).fill(1));
            const stack = [{x:1, y:1}];
            map[1][1] = 0;
            const dirs = [{x:0,y:-2},{x:0,y:2},{x:-2,y:0},{x:2,y:0}];

            while(stack.length > 0) {
                const cur = stack[stack.length-1];
                const neighbors = [];
                dirs.forEach(d => {
                    const nx = cur.x+d.x, ny = cur.y+d.y;
                    if(nx>0 && nx<cols-1 && ny>0 && ny<rows-1 && map[ny][nx]===1) 
                        neighbors.push({x:nx, y:ny, dx:d.x/2, dy:d.y/2});
                });
                if(neighbors.length>0) {
                    const next = neighbors[Math.floor(Math.random()*neighbors.length)];
                    map[next.y][next.x] = 0;
                    map[cur.y+next.dy][cur.x+next.dx] = 0;
                    stack.push({x:next.x, y:next.y});
                } else stack.pop();
            }
            // Meno vicoli ciechi
            for(let y=1; y<rows-1; y++) for(let x=1; x<cols-1; x++) 
                if(map[y][x]===1 && Math.random()<0.25) { // 25% muri rimossi
                    let c=0; 
                    if(map[y-1][x])c++; if(map[y+1][x])c++; if(map[y][x-1])c++; if(map[y][x+1])c++;
                    if(c>=2) map[y][x]=0;
                }
            const cx=Math.floor(cols/2), cy=Math.floor(rows/2);
            map[cy][cx]=0; map[cy][cx+1]=0; map[cy][cx-1]=0; map[cy+1][cx]=0; map[cy-1][cx]=0;
            return map;
        }
    };

    const MazeGame = {
      canvas: null, ctx: null,
      gridSize: 0, rows: 21, cols: 13,
      loopId: null, score: 0, state: 'stop',
      mapLayout: [], items: [], enemies: [],
      
      // Settings Velocit√†
      // Player: Base 0.20, Boost 0.40
      // Enemies: Smart 0.12, Dumb 0.10
      playerBaseSpeed: 0.20,
      playerBoostSpeed: 0.40,
      
      player: { x: 1, y: 1, currentDir: {x:0,y:0}, speed: 0.2, progress: 0 },
      moveQueue: [], 
      targetPos: null,
      boostTimer: null,

      init: function() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        const handleInput = (e) => {
            if(this.state !== 'playing') return;
            e.preventDefault();
            const rect = this.canvas.getBoundingClientRect();
            let cx, cy;
            if(e.type.startsWith('touch')) { cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY; }
            else { cx = e.clientX; cy = e.clientY; }

            const tx = Math.floor((cx - rect.left) / this.gridSize);
            const ty = Math.floor((cy - rect.top) / this.gridSize);

            if(tx >= 0 && tx < this.cols && ty >= 0 && ty < this.rows && this.mapLayout[ty][tx] === 0) {
                this.targetPos = {x: tx, y: ty};
                
                // Se mi sto muovendo, calcolo dalla prossima cella, altrimenti da quella attuale
                let startNode = { x: Math.round(this.player.x), y: Math.round(this.player.y) };
                if(this.player.progress > 0) {
                    startNode.x += this.player.currentDir.x;
                    startNode.y += this.player.currentDir.y;
                }

                const newPath = Pathfinder.findPath(this.mapLayout, startNode, this.targetPos);
                this.moveQueue = newPath;
            }
        };

        this.canvas.addEventListener('mousedown', handleInput);
        this.canvas.addEventListener('touchstart', handleInput, {passive: false});
      },

      resize: function() {
        const wrapper = document.getElementById('game-wrapper');
        const sW = Math.floor((wrapper.clientWidth-10)/this.cols);
        const sH = Math.floor((wrapper.clientHeight-10)/this.rows);
        this.gridSize = Math.min(sW, sH);
        this.canvas.width = this.gridSize * this.cols;
        this.canvas.height = this.gridSize * this.rows;
        if(this.state === 'stop') this.draw();
      },

      start: function() {
        document.querySelectorAll('.overlay').forEach(el => el.classList.add('hidden'));
        document.querySelectorAll('.hud-item').forEach(el => el.classList.remove('collected'));
        this.endBoost(); // Reset boost

        this.mapLayout = MazeGen.generate(this.rows, this.cols);
        this.placeEntities();
        
        this.score = 0;
        this.moveQueue = [];
        this.targetPos = null;
        document.getElementById('score-val').innerText = '0';
        this.state = 'playing';
        this.loop();
      },

      activateBoost: function() {
        if(this.boostTimer) clearTimeout(this.boostTimer);
        this.player.speed = this.playerBoostSpeed;
        
        // Visual effects
        document.getElementById('score-box').classList.add('score-boosted');
        document.getElementById('game-wrapper').classList.add('game-boosted');
        
        this.boostTimer = setTimeout(() => {
            this.endBoost();
        }, 3000); // 3 secondi
      },

      endBoost: function() {
        this.player.speed = this.playerBaseSpeed;
        document.getElementById('score-box').classList.remove('score-boosted');
        document.getElementById('game-wrapper').classList.remove('game-boosted');
      },

      placeEntities: function() {
        let free = [];
        for(let y=1; y<this.rows-1; y++) for(let x=1; x<this.cols-1; x++) 
            if(this.mapLayout[y][x] === 0) free.push({x,y});
        
        free.sort(() => Math.random() - 0.5);
        const cx=Math.floor(this.cols/2), cy=Math.floor(this.rows/2);
        let pSpot = free.find(s => Math.abs(s.x-cx)<3 && Math.abs(s.y-cy)<3) || free[0];
        
        this.player = { x: pSpot.x, y: pSpot.y, currentDir: {x:0, y:0}, speed: this.playerBaseSpeed, progress: 0 };
        
        free = free.filter(s => s!==pSpot);
        // Distanza massima per oggetti e nemici
        free.sort((a,b) => {
            const dA = Math.abs(a.x-pSpot.x)+Math.abs(a.y-pSpot.y);
            const dB = Math.abs(b.x-pSpot.x)+Math.abs(b.y-pSpot.y);
            return dB - dA;
        });

        this.items = [
            { id: 'heart', icon: '‚ù§Ô∏è', x: free[0].x, y: free[0].y, collected: false },
            { id: 'house', icon: 'üè†', x: free[1].x, y: free[1].y, collected: false },
            { id: 'dance', icon: 'üíÉ', x: free[2].x, y: free[2].y, collected: false },
            { id: 'travel', icon: '‚úàÔ∏è', x: free[3].x, y: free[3].y, collected: false }
        ];

        let eSpots = free.slice(4, 7);
        this.enemies = [
            // Valigetta: Stupida (Random), Lenta
            { type: 'dumb', icon: 'üíº', x: eSpots[0].x, y: eSpots[0].y, dir: {x:0, y:0}, speed: 0.10, progress: 0 },
            // Mail: Intelligente (Pathfinder), Media velocit√†
            { type: 'smart', icon: 'üìß', x: eSpots[1].x, y: eSpots[1].y, dir: {x:0, y:0}, speed: 0.12, progress: 0 },
            // Telefono: Intelligente, Un po' pi√π veloce
            { type: 'smart', icon: 'üìû', x: eSpots[2].x, y: eSpots[2].y, dir: {x:0, y:0}, speed: 0.13, progress: 0 }
        ];
      },

      // --- LOGICA NEMICI ---
      decideEnemyMove: function(enemy) {
          // Se √® intelligente, usa il pathfinder verso il player
          if(enemy.type === 'smart') {
              // Calcola percorso verso player
              // Nota: Calcoliamo il path partendo dalla posizione intera corrente
              const path = Pathfinder.findPath(this.mapLayout, enemy, this.player);
              if(path && path.length > 0) {
                  return path[0]; // Prendi il primo passo
              }
          }
          
          // Fallback per "dumb" o se il path fallisce (random)
          const dirs = [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}];
          let valid = [];
          dirs.forEach(d => {
              if(enemy.x+d.x>=0 && enemy.x+d.x<this.cols && enemy.y+d.y>=0 && enemy.y+d.y<this.rows && this.mapLayout[enemy.y+d.y][enemy.x+d.x]!==1) {
                  // Non tornare indietro subito se possibile
                  if(!(enemy.dir && d.x===-enemy.dir.x && d.y===-enemy.dir.y)) valid.push(d);
              }
          });
          
          if(valid.length === 0) return {x:0, y:0}; // Stuck
          return valid[Math.floor(Math.random() * valid.length)];
      },

      moveActor: function(actor, isPlayer) {
        if(actor.progress > 0) {
            actor.progress += actor.speed;
            if(actor.progress >= 1) {
                // Fine movimento tile
                actor.progress = 0;
                actor.x += actor.currentDir.x;
                actor.y += actor.currentDir.y;
                actor.currentDir = {x:0, y:0};
                
                if(isPlayer && this.targetPos && actor.x === this.targetPos.x && actor.y === this.targetPos.y) {
                    this.targetPos = null;
                }
            }
            return;
        }

        // Se fermo, decidi prossima mossa
        if(isPlayer) {
            if(this.moveQueue.length > 0) {
                actor.currentDir = this.moveQueue.shift();
                actor.progress = actor.speed;
            }
        } else {
            // Nemici decidono ORA dove andare
            actor.currentDir = this.decideEnemyMove(actor);
            if(actor.currentDir.x !== 0 || actor.currentDir.y !== 0) {
                actor.progress = actor.speed;
            }
        }
      },

      checkCollisions: function() {
        const px = this.player.x + (this.player.currentDir.x * this.player.progress);
        const py = this.player.y + (this.player.currentDir.y * this.player.progress);
        
        // Items
        this.items.forEach(i => {
            if(!i.collected) {
                if(Math.sqrt((px-i.x)**2 + (py-i.y)**2) < 0.6) {
                    i.collected = true;
                    this.score += 100;
                    document.getElementById('score-val').innerText = this.score;
                    document.getElementById(`hud-${i.id}`).classList.add('collected');
                    
                    // BOOST!
                    this.activateBoost();

                    if(this.items.every(x => x.collected)) this.gameOver(true);
                }
            }
        });
        
        // Enemies (Hitbox leggermente pi√π permissiva per dare chance)
        this.enemies.forEach(e => {
            const ex = e.x + (e.currentDir.x * e.progress);
            const ey = e.y + (e.currentDir.y * e.progress);
            if(Math.sqrt((px-ex)**2 + (py-ey)**2) < 0.5) this.gameOver(false);
        });
      },

      gameOver: function(win) {
        this.state = win ? 'win' : 'lose';
        if(win) {
            this.score += 100;
            document.getElementById('score-val').innerText = this.score;
            document.getElementById('win-screen').classList.remove('hidden');
        } else {
            document.getElementById('final-score-lose').innerText = this.score;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }
      },

      update: function() {
        if(this.state !== 'playing') return;
        this.moveActor(this.player, true);
        this.enemies.forEach(e => this.moveActor(e, false));
        this.checkCollisions();
      },

      draw: function() {
        const ctx = this.ctx;
        const gs = this.gridSize;
        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-color');
        ctx.fillRect(0,0,this.canvas.width, this.canvas.height);

        // Mappa
        for(let r=0; r<this.rows; r++) {
            for(let c=0; c<this.cols; c++) {
                if(this.mapLayout[r][c] === 1) {
                    ctx.fillStyle = '#1e293b'; ctx.fillRect(c*gs, r*gs, gs, gs);
                    ctx.fillStyle = '#0f172a'; ctx.fillRect(c*gs+gs*0.25, r*gs+gs*0.25, gs*0.5, gs*0.5);
                }
            }
        }

        // Target Marker
        if(this.targetPos) {
            ctx.strokeStyle = '#4cd964'; ctx.lineWidth = 2;
            const tx = this.targetPos.x*gs + gs/2; const ty = this.targetPos.y*gs + gs/2;
            const pulse = (Math.sin(Date.now()/100) + 1) * 0.5; 
            const size = (gs*0.2) + (pulse * 4);
            ctx.beginPath(); ctx.arc(tx, ty, size, 0, Math.PI*2); ctx.stroke();
        }

        // Items
        ctx.font = `${gs*0.6}px Arial`; ctx.textAlign='center'; ctx.textBaseline='middle';
        this.items.forEach(i => {
            if(!i.collected) ctx.fillText(i.icon, i.x*gs+gs/2, i.y*gs+gs/2+2);
        });

        // Player
        const px = (this.player.x + this.player.currentDir.x*this.player.progress)*gs + gs/2;
        const py = (this.player.y + this.player.currentDir.y*this.player.progress)*gs + gs/2;
        ctx.font = `${gs*0.8}px Arial`;
        ctx.shadowBlur = this.player.speed > 0.3 ? 15 : 0; // Glow se veloce
        ctx.shadowColor = '#facc15';
        ctx.fillText('ü§ñ', px, py+3);
        ctx.shadowBlur = 0;

        // Enemies
        this.enemies.forEach(e => {
            const ex = (e.x + e.currentDir.x*e.progress)*gs + gs/2;
            const ey = (e.y + e.currentDir.y*e.progress)*gs + gs/2;
            ctx.fillText(e.icon, ex, ey+3);
        });
      },

      loop: function() {
        if(this.state !== 'playing') return;
        this.update();
        this.draw();
        this.loopId = requestAnimationFrame(() => this.loop());
      }
    };

    window.onload = function() { MazeGame.init(); };
  </script>
</body>
</html>
