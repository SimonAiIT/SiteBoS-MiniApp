<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Work Escape V3 - Tap Control</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <style>
    :root {
      --bg-color: #0f172a;
      --wall-color: #1e293b;
      --wall-border: #334155;
      --primary: #5B6FED;
      --accent: #4cd964;
      --danger: #ff6b6b;
    }

    body {
      margin: 0; padding: 0;
      background-color: var(--bg-color);
      color: #f8fafc;
      font-family: 'Inter', sans-serif;
      overflow: hidden; touch-action: none;
      display: flex; flex-direction: column;
      height: 100vh; user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* HEADER */
    .game-header {
      padding: 10px 15px;
      display: flex; justify-content: space-between; align-items: center;
      background: rgba(0,0,0,0.3); z-index: 10;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      height: 50px; box-sizing: border-box;
    }
    .score-container { font-family: 'Orbitron', sans-serif; font-size: 18px; color: #fff; text-shadow: 0 0 5px var(--primary); }
    .close-btn { background: none; border: none; color: #94a3b8; font-size: 20px; cursor: pointer; }

    /* GAME AREA */
    #game-wrapper {
      flex: 1; position: relative;
      display: flex; justify-content: center; align-items: center;
      background: var(--bg-color);
      overflow: hidden;
    }

    canvas {
      box-shadow: 0 0 30px rgba(0,0,0,0.6);
      border-radius: 4px;
    }

    /* OVERLAYS */
    .overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(15, 23, 42, 0.96);
      display: flex; flex-direction: column;
      justify-content: center; align-items: center;
      z-index: 20; text-align: center;
      backdrop-filter: blur(5px);
    }
    .hidden { display: none !important; }

    h2 { font-family: 'Orbitron'; font-size: 28px; margin: 0 0 10px 0; }
    .win-text { color: var(--accent); }
    .lose-text { color: var(--danger); }
    
    .btn-action {
      background: var(--primary); color: white; border: none;
      padding: 14px 35px; border-radius: 30px;
      font-size: 16px; font-weight: 600; margin-top: 25px;
      cursor: pointer; box-shadow: 0 4px 15px rgba(91, 111, 237, 0.4);
      transition: transform 0.1s;
    }
    .btn-action:active { transform: scale(0.95); }

    .items-hud { display: flex; gap: 15px; margin-bottom: 20px; }
    .hud-item { font-size: 24px; opacity: 0.3; filter: grayscale(100%); transition: all 0.3s; }
    .hud-item.collected { opacity: 1; filter: grayscale(0%); transform: scale(1.3); text-shadow: 0 0 10px rgba(255,255,255,0.5); }

    /* CLICK EFFECT */
    .click-effect {
      position: absolute; width: 40px; height: 40px;
      border: 2px solid rgba(255,255,255,0.5); border-radius: 50%;
      pointer-events: none; animation: ripple 0.4s ease-out forwards;
      transform: translate(-50%, -50%); z-index: 5;
    }
    @keyframes ripple { from { width: 10px; height: 10px; opacity: 1; } to { width: 60px; height: 60px; opacity: 0; } }

  </style>
</head>
<body>

  <div class="game-header">
    <div class="score-container">SCORE: <span id="score-val">0</span>/500</div>
    <button class="close-btn"><i class="fas fa-times"></i></button>
  </div>

  <div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>

    <!-- START SCREEN -->
    <div id="start-screen" class="overlay">
      <div style="font-size:60px; margin-bottom:10px;">ü§ñ</div>
      <h2>WORK ESCAPE</h2>
      <p style="color:#cbd5e1; margin-bottom:20px;">Nuova Mappa Casuale Generata</p>
      
      <div class="items-hud">
        <span id="hud-heart" class="hud-item">‚ù§Ô∏è</span>
        <span id="hud-house" class="hud-item">üè†</span>
        <span id="hud-dance" class="hud-item">üíÉ</span>
        <span id="hud-travel" class="hud-item">‚úàÔ∏è</span>
      </div>

      <button class="btn-action" onclick="MazeGame.start()">GIOCA ORA</button>
      <div style="font-size:12px; color:#64748b; margin-top:20px;">
        TOCCA LO SCHERMO NELLA DIREZIONE<br>DOVE VUOI ANDARE
      </div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="game-over-screen" class="overlay hidden">
      <div style="font-size:60px; margin-bottom:10px;">üíÄ</div>
      <h2 class="lose-text">PRESO!</h2>
      <p style="color:#cbd5e1;">Il lavoro vince sempre...</p>
      <p style="font-family:'Orbitron'; font-size:20px;">Punti: <span id="final-score-lose">0</span></p>
      <button class="btn-action" onclick="MazeGame.start()">RIPROVA</button>
    </div>

    <!-- WIN SCREEN -->
    <div id="win-screen" class="overlay hidden">
      <div style="font-size:60px; margin-bottom:10px;">üèÜ</div>
      <h2 class="win-text">LIBERT√Ä!</h2>
      <p style="color:#cbd5e1;">Hai completato la tua vita!</p>
      <div style="background:rgba(76, 217, 100, 0.2); color:#4cd964; padding:10px 20px; border-radius:10px; margin-top:15px; font-weight:bold; font-family:'Orbitron';">
        TOTALE: 500 PUNTI
      </div>
      <button class="btn-action" onclick="MazeGame.start()">NUOVA PARTITA</button>
    </div>
  </div>

  <script>
    // --- GENERATORE DI LABIRINTI ---
    const MazeGen = {
        generate: function(rows, cols) {
            let map = [];
            for(let y=0; y<rows; y++) {
                let row = [];
                for(let x=0; x<cols; x++) row.push(1);
                map.push(row);
            }

            const stack = [];
            const startX = 1; const startY = 1;
            map[startY][startX] = 0;
            stack.push({x: startX, y: startY});

            const dirs = [{x:0, y:-2}, {x:0, y:2}, {x:-2, y:0}, {x:2, y:0}];

            while(stack.length > 0) {
                const current = stack[stack.length-1];
                const neighbors = [];
                dirs.forEach(d => {
                    const nx = current.x + d.x; const ny = current.y + d.y;
                    if(nx > 0 && nx < cols-1 && ny > 0 && ny < rows-1 && map[ny][nx] === 1) {
                        neighbors.push({x: nx, y: ny, dx: d.x/2, dy: d.y/2});
                    }
                });
                if(neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    map[next.y][next.x] = 0; 
                    map[current.y + next.dy][current.x + next.dx] = 0; 
                    stack.push({x: next.x, y: next.y});
                } else {
                    stack.pop();
                }
            }
            // Loop extra per meno vicoli ciechi
            for(let y=1; y<rows-1; y++) {
                for(let x=1; x<cols-1; x++) {
                    if(map[y][x] === 1 && Math.random() < 0.2) { 
                        let nw = 0;
                        if(map[y-1][x]===1) nw++; if(map[y+1][x]===1) nw++;
                        if(map[y][x-1]===1) nw++; if(map[y][x+1]===1) nw++;
                        if(nw >= 2) map[y][x] = 0;
                    }
                }
            }
            const cx = Math.floor(cols/2); const cy = Math.floor(rows/2);
            map[cy][cx] = 0; map[cy][cx+1] = 0; map[cy][cx-1] = 0; map[cy+1][cx] = 0; map[cy-1][cx] = 0;
            return map;
        }
    };

    // --- LOGICA GIOCO ---
    const MazeGame = {
      canvas: null, ctx: null,
      gridSize: 0, rows: 21, cols: 13, // Mappa leggermente pi√π alta
      loopId: null, score: 0, state: 'stop',
      mapLayout: [], items: [], enemies: [],
      player: { x: 1, y: 1, nextDir: null, currentDir: null, speed: 0.15, progress: 0, rot: 0 },

      init: function() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // --- NUOVO SISTEMA INPUT: CLICK TO DIRECTION ---
        const handleInput = (e) => {
            if(this.state !== 'playing') return;
            
            // Ottieni coordinate click/touch relative al wrapper
            const rect = this.canvas.getBoundingClientRect();
            let clientX, clientY;
            
            if(e.type === 'touchstart' || e.type === 'mousedown') {
               if(e.type === 'touchstart') {
                   clientX = e.changedTouches[0].clientX;
                   clientY = e.changedTouches[0].clientY;
               } else {
                   clientX = e.clientX;
                   clientY = e.clientY;
               }
               
               // Effetto Visivo
               this.spawnClickEffect(clientX, clientY);

               // Coordinate click relative al canvas
               const inputX = clientX - rect.left;
               const inputY = clientY - rect.top;

               // Posizione Player in pixel sul canvas
               const playerScreenX = (this.player.x + 0.5) * this.gridSize;
               const playerScreenY = (this.player.y + 0.5) * this.gridSize;

               // Differenza
               const dx = inputX - playerScreenX;
               const dy = inputY - playerScreenY;

               // Determina direzione dominante
               if(Math.abs(dx) > Math.abs(dy)) {
                   // Movimento Orizzontale
                   this.player.nextDir = dx > 0 ? {x:1, y:0} : {x:-1, y:0};
               } else {
                   // Movimento Verticale
                   this.player.nextDir = dy > 0 ? {x:0, y:1} : {x:0, y:-1};
               }
            }
        };

        // Event Listeners
        this.canvas.addEventListener('mousedown', handleInput);
        this.canvas.addEventListener('touchstart', handleInput, {passive: false});
        
        // Previeni scroll
        this.canvas.addEventListener('touchmove', (e) => e.preventDefault(), {passive:false});

        // Keyboard Support
        window.addEventListener('keydown', (e) => {
            if(this.state !== 'playing') return;
            if(e.key === 'ArrowUp' || e.key === 'w') this.player.nextDir = {x:0, y:-1};
            if(e.key === 'ArrowDown' || e.key === 's') this.player.nextDir = {x:0, y:1};
            if(e.key === 'ArrowLeft' || e.key === 'a') this.player.nextDir = {x:-1, y:0};
            if(e.key === 'ArrowRight' || e.key === 'd') this.player.nextDir = {x:1, y:0};
        });
      },

      spawnClickEffect: function(x, y) {
        const el = document.createElement('div');
        el.className = 'click-effect';
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 400);
      },

      resize: function() {
        const wrapper = document.getElementById('game-wrapper');
        const maxWidth = wrapper.clientWidth - 10;
        const maxHeight = wrapper.clientHeight - 10;
        
        const sizeByW = Math.floor(maxWidth / this.cols);
        const sizeByH = Math.floor(maxHeight / this.rows);
        this.gridSize = Math.min(sizeByW, sizeByH);
        
        this.canvas.width = this.gridSize * this.cols;
        this.canvas.height = this.gridSize * this.rows;
        if(this.state === 'stop') this.draw();
      },

      start: function() {
        document.querySelectorAll('.overlay').forEach(el => el.classList.add('hidden'));
        document.querySelectorAll('.hud-item').forEach(el => el.classList.remove('collected'));
        this.mapLayout = MazeGen.generate(this.rows, this.cols);
        this.placeEntities();
        this.score = 0;
        document.getElementById('score-val').innerText = '0';
        this.state = 'playing';
        this.loop();
      },

      placeEntities: function() {
        let freeSpots = [];
        for(let y=1; y<this.rows-1; y++) {
            for(let x=1; x<this.cols-1; x++) {
                if(this.mapLayout[y][x] === 0) freeSpots.push({x,y});
            }
        }
        
        const shuffle = (arr) => arr.sort(() => Math.random() - 0.5);
        freeSpots = shuffle(freeSpots);

        const cx = Math.floor(this.cols/2);
        const cy = Math.floor(this.rows/2);
        let pSpot = freeSpots.find(s => Math.abs(s.x-cx) < 3 && Math.abs(s.y-cy) < 3) || freeSpots[0];
        this.player = { x: pSpot.x, y: pSpot.y, nextDir: {x:0, y:0}, currentDir: {x:0, y:0}, speed: 0.15, progress: 0, rot:0 };

        // Ordina per distanza per nemici e oggetti
        freeSpots.sort((a,b) => {
            const dA = Math.pow(a.x-this.player.x,2) + Math.pow(a.y-this.player.y,2);
            const dB = Math.pow(b.x-this.player.x,2) + Math.pow(b.y-this.player.y,2);
            return dB - dA;
        });

        this.items = [
            { id: 'heart', icon: '‚ù§Ô∏è', x: freeSpots[0].x, y: freeSpots[0].y, collected: false },
            { id: 'house', icon: 'üè†', x: freeSpots[1].x, y: freeSpots[1].y, collected: false },
            { id: 'dance', icon: 'üíÉ', x: freeSpots[2].x, y: freeSpots[2].y, collected: false },
            { id: 'travel', icon: '‚úàÔ∏è', x: freeSpots[3].x, y: freeSpots[3].y, collected: false }
        ];

        let enemySpots = freeSpots.slice(4, 7);
        this.enemies = [
            { type: 'random', icon: 'üíº', x: enemySpots[0].x, y: enemySpots[0].y, dir: {x:0, y:0}, speed: 0.08, progress: 0 },
            { type: 'chase', icon: 'üìß', x: enemySpots[1].x, y: enemySpots[1].y, dir: {x:0, y:0}, speed: 0.09, progress: 0 },
            { type: 'fast', icon: 'üìû', x: enemySpots[2].x, y: enemySpots[2].y, dir: {x:0, y:0}, speed: 0.12, progress: 0 }
        ];
      },

      isWall: function(x, y) {
        if(x < 0 || x >= this.cols || y < 0 || y >= this.rows) return true;
        return this.mapLayout[y][x] === 1;
      },

      getBestMove: function(enemy) {
        const dirs = [{x:0,y:-1}, {x:0,y:1}, {x:-1,y:0}, {x:1,y:0}];
        let validMoves = [];

        dirs.forEach(d => {
            if(!this.isWall(enemy.x + d.x, enemy.y + d.y)) {
                if(enemy.dir && (d.x === -enemy.dir.x && d.y === -enemy.dir.y)) {
                    validMoves.push({d, score: -100}); 
                } else {
                    validMoves.push({d, score: 0});
                }
            }
        });

        if(validMoves.length === 0) return {x:-enemy.dir.x, y:-enemy.dir.y};

        validMoves.forEach(m => {
            if(m.score === -100 && validMoves.length > 1) return;
            const tx = enemy.x + m.d.x; const ty = enemy.y + m.d.y;
            const dist = Math.abs(tx - this.player.x) + Math.abs(ty - this.player.y);

            if(enemy.type === 'chase') m.score -= dist; 
            else if (enemy.type === 'random') m.score += Math.random() * 50;
            else if (enemy.type === 'fast') { m.score -= dist * 0.5; m.score += Math.random() * 20; }
        });
        validMoves.sort((a,b) => b.score - a.score);
        return validMoves[0].d;
      },

      moveActor: function(actor, isPlayer) {
        if(actor.progress > 0) {
          actor.progress += actor.speed;
          if(actor.progress >= 1) {
            actor.progress = 0;
            actor.x += actor.currentDir.x;
            actor.y += actor.currentDir.y;
            actor.currentDir = {x:0, y:0};
          }
          return;
        }

        if(isPlayer) {
          // Player Buffer Logic
          if(actor.nextDir && (actor.nextDir.x !== 0 || actor.nextDir.y !== 0)) {
             if(!this.isWall(actor.x + actor.nextDir.x, actor.y + actor.nextDir.y)) {
               actor.currentDir = actor.nextDir;
               actor.progress = actor.speed;
               if(actor.currentDir.x === 1) actor.rot = 0;
               if(actor.currentDir.x === -1) actor.rot = Math.PI;
               if(actor.currentDir.y === 1) actor.rot = Math.PI/2;
               if(actor.currentDir.y === -1) actor.rot = -Math.PI/2;
               return;
             }
          }
          if(actor.currentDir.x !== 0 || actor.currentDir.y !== 0) {
            if(!this.isWall(actor.x + actor.currentDir.x, actor.y + actor.currentDir.y)) {
               actor.progress = actor.speed;
            } else { actor.currentDir = {x:0, y:0}; }
          }
        } else {
          const move = this.getBestMove(actor);
          actor.currentDir = move;
          actor.progress = actor.speed;
        }
      },

      checkCollisions: function() {
        const px = this.player.x + (this.player.currentDir.x * this.player.progress);
        const py = this.player.y + (this.player.currentDir.y * this.player.progress);
        
        this.items.forEach(item => {
          if(!item.collected) {
            const dist = Math.sqrt(Math.pow(px-item.x, 2) + Math.pow(py-item.y, 2));
            if(dist < 0.6) {
              item.collected = true;
              this.score += 100;
              document.getElementById('score-val').innerText = this.score;
              document.getElementById(`hud-${item.id}`).classList.add('collected');
              if(this.items.every(i => i.collected)) this.gameOver(true);
            }
          }
        });

        this.enemies.forEach(en => {
           const ex = en.x + (en.currentDir.x * en.progress);
           const ey = en.y + (en.currentDir.y * en.progress);
           const dist = Math.sqrt( Math.pow(px-ex, 2) + Math.pow(py-ey, 2) );
           if(dist < 0.6) this.gameOver(false);
        });
      },

      gameOver: function(win) {
        this.state = win ? 'win' : 'lose';
        if(win) {
            this.score += 100;
            document.getElementById('score-val').innerText = this.score;
            document.getElementById('win-screen').classList.remove('hidden');
        } else {
            document.getElementById('final-score-lose').innerText = this.score;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }
      },

      update: function() {
        if(this.state !== 'playing') return;
        this.moveActor(this.player, true);
        this.enemies.forEach(en => this.moveActor(en, false));
        this.checkCollisions();
      },

      draw: function() {
        this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-color');
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        const gs = this.gridSize;

        for(let r=0; r<this.rows; r++) {
          for(let c=0; c<this.cols; c++) {
            if(this.mapLayout[r][c] === 1) {
              const x = c * gs, y = r * gs;
              this.ctx.fillStyle = '#1e293b';
              this.ctx.fillRect(x, y, gs, gs);
              this.ctx.strokeStyle = '#334155';
              this.ctx.lineWidth = 1;
              this.ctx.strokeRect(x,y,gs,gs);
              this.ctx.fillStyle = '#0f172a';
              this.ctx.fillRect(x+gs*0.25, y+gs*0.25, gs*0.5, gs*0.5);
            }
          }
        }

        this.ctx.font = `${gs*0.6}px Arial`;
        this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
        this.items.forEach(item => {
          if(!item.collected) {
            const x = (item.x * gs) + gs/2;
            const y = (item.y * gs) + gs/2 + 2;
            this.ctx.fillText(item.icon, x, y);
          }
        });

        const px = (this.player.x + (this.player.currentDir.x * this.player.progress)) * gs + gs/2;
        const py = (this.player.y + (this.player.currentDir.y * this.player.progress)) * gs + gs/2;
        this.ctx.save();
        this.ctx.translate(px, py);
        this.ctx.font = `${gs*0.8}px Arial`;
        this.ctx.fillText('ü§ñ', 0, 4);
        this.ctx.restore();

        this.enemies.forEach(en => {
          const ex = (en.x + (en.currentDir.x * en.progress)) * gs + gs/2;
          const ey = (en.y + (en.currentDir.y * en.progress)) * gs + gs/2 + 4;
          this.ctx.fillText(en.icon, ex, ey);
        });
      },

      loop: function() {
        if(this.state !== 'playing') return;
        this.update();
        this.draw();
        this.loopId = requestAnimationFrame(() => this.loop());
      }
    };
    window.onload = function() { MazeGame.init(); };
  </script>
</body>
</html>
